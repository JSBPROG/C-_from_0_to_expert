# üìò Fundamental Data Types en C++

Este documento explica en detalle los **tipos de datos fundamentales en C++**, c√≥mo se representan en memoria, y el uso de **`nullptr` y punteros nulos**.

---

## üß© Bits, bytes y memoria

- La memoria del computador est√° formada por **bits** (0 o 1).  
- 8 bits forman **1 byte**, la unidad m√≠nima direccionable.  
- Cada variable que definimos ocupa cierto n√∫mero de bytes dependiendo de su **tipo de dato**.  
- Los **tipos de datos fundamentales** le dicen al compilador **c√≥mo interpretar** los bits almacenados en memoria.

---

## üóÇÔ∏è Tabla de tipos fundamentales

| Tipo | Categor√≠a | Tama√±o aproximado (depende del compilador/arquitectura) | Significado | Ejemplo |
|------|-----------|---------------------------------------------------------|-------------|---------|
| `bool` | Integral (booleano) | 1 byte | Solo puede valer `true` (1) o `false` (0). Usado para condiciones l√≥gicas. | `bool activo = true;` |
| `char` | Integral (car√°cter) | 1 byte | Representa un car√°cter ASCII. Tambi√©n se puede usar como n√∫mero entero peque√±o. | `char c = 'A';` |
| `wchar_t` | Integral (car√°cter) | 2‚Äì4 bytes | Car√°cter ‚Äúancho‚Äù, permite Unicode. | `wchar_t wc = L'Œ©';` |
| `char16_t` (C++11) | Integral (car√°cter) | 2 bytes | Car√°cter codificado en UTF-16. | `char16_t c16 = u'„ÅÇ';` |
| `char32_t` (C++11) | Integral (car√°cter) | 4 bytes | Car√°cter codificado en UTF-32. | `char32_t c32 = U'êçà';` |
| `short` | Entero | ‚â• 2 bytes | Entero corto (positivo o negativo). | `short s = -120;` |
| `int` | Entero | 4 bytes t√≠pico | Entero est√°ndar, el m√°s usado. | `int edad = 25;` |
| `long` | Entero | 4‚Äì8 bytes | Entero m√°s grande que `int`. | `long poblacion = 1000000;` |
| `long long` (C++11) | Entero | ‚â• 8 bytes | Entero a√∫n m√°s grande. | `long long estrellas = 9000000000;` |
| `float` | Punto flotante | 4 bytes | N√∫mero con decimales (precisi√≥n simple). | `float pi = 3.14f;` |
| `double` | Punto flotante | 8 bytes | N√∫mero decimal de doble precisi√≥n. | `double e = 2.71828;` |
| `long double` | Punto flotante | 8‚Äì16 bytes | Mayor precisi√≥n que `double`. | `long double phi = 1.6180339887;` |
| `void` | Especial | 0 bytes | Representa ‚Äúsin tipo‚Äù. Se usa en funciones que no retornan nada. | `void saludar();` |
| `std::nullptr_t` (C++11) | Null pointer | Tama√±o de un puntero | Representa el valor nulo de un puntero. | `int* p = nullptr;` |

---

## üß† Explicaci√≥n extendida de algunos tipos

### üîπ `bool`
- Puede ser `true` o `false`.  
- Internamente suele representarse con **1 byte**, aunque solo necesita 1 bit.  
- Se usa para condiciones en `if`, `while`, etc.

---

### üîπ Tipos `char` y derivados
- `char` almacena un car√°cter ASCII (ej: `'A'`, `'7'`, `'%'`).  
- Como tambi√©n es un n√∫mero entero, puedes hacer operaciones con √©l:  
  ```cpp
  char c = 'A';
  cout << (int)c; // muestra 65
  ```
- Los tipos `wchar_t`, `char16_t`, `char32_t` se usan para Unicode, permitiendo representar caracteres internacionales.

---

### üîπ Tipos enteros (`short`, `int`, `long`, `long long`)
- Almacenan n√∫meros enteros (positivos, negativos o cero).  
- Tambi√©n existen **versiones sin signo** (`unsigned int`, etc.), que solo permiten valores ‚â• 0, pero duplican el rango positivo.  

---

### üîπ Tipos de punto flotante (`float`, `double`, `long double`)
- Usados para n√∫meros con parte decimal.  
- Ejemplo:  
  ```cpp
  double pi = 3.1415926535;
  ```
- Cuidado: **los decimales se representan de forma aproximada** en binario, por lo que pueden existir errores de precisi√≥n.

---

### üîπ `void`
- Se usa cuando una funci√≥n no retorna valor:  
  ```cpp
  void imprimirHola() {
      cout << "Hola\n";
  }
  ```
- Tambi√©n puede indicar ‚Äúpuntero a tipo gen√©rico‚Äù: `void*`.

---

### üîπ `nullptr` y punteros nulos
Un **puntero** almacena la direcci√≥n de memoria de otra variable.  
Ejemplo:
```cpp
int x = 10;
int* p = &x; // p apunta a x
```

Pero a veces queremos un puntero que **no apunte a nada v√°lido a√∫n**.  
Ah√≠ entra `nullptr`:

```cpp
int* ptr = nullptr; // puntero nulo
if (ptr == nullptr) {
    cout << "El puntero no apunta a nada." << endl;
}
```

#### ‚úÖ ¬øPara qu√© sirve `nullptr`?
- **Inicializar punteros** para evitar que apunten a basura en memoria.  
- **Comprobar si un puntero es v√°lido** antes de usarlo.  
- **Se√±alar condiciones especiales**, por ejemplo:  
  - una funci√≥n que devuelve un puntero a un objeto puede retornar `nullptr` si no encontr√≥ nada.  
- **Evitar ambig√ºedad con enteros**: `nullptr` es m√°s seguro que `NULL` (que era solo `0`).

#### ‚ö†Ô∏è Importante:
- **Nunca intentes acceder a un puntero nulo**:
  ```cpp
  int* p = nullptr;
  cout << *p; // ERROR en tiempo de ejecuci√≥n (segmentation fault)
  ```

---

## üìö Resumen final
1. Los **tipos fundamentales** son la base del lenguaje C++.  
2. Cada tipo ocupa una cantidad de bytes y tiene un prop√≥sito espec√≠fico.  
3. `nullptr` es la forma **moderna, segura y clara** de representar un puntero que no apunta a nada.  
4. Siempre **inicializa tus punteros** (con `nullptr` o una direcci√≥n v√°lida) para evitar errores graves.  
